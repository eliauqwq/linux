# >>>>>>数据结构之红黑树

在之前的学习当中，我们了解到了一种利于排序和查找的数据结构——**搜索二叉树**。但单纯的搜索二叉树存在样本本身如果过于有序那么就容易退化成链表的这一问题，因此我们继续深入学习了AVL——平衡搜索二叉树。这种结构强调完全的平衡，但在大多数情况下，我们不需要结构过于平衡。而今天了解到的红黑树就是这种近似平衡的结构

## 红黑树的原理及特点
在红黑树中，某个结点到叶子节点的最长路径不会超过最短路径的两倍，这相较于AVL树的完全平衡所需要的代价更低，更好实现。在同样的样本情况下AVL的旋转次数往往远大于红黑树，对于我们的计算机而言，总体下来还是红黑树的性能更加的优越

**红黑树的特点**：

1. 结点不是黑色就是红色
2. 根节点一定是黑色的
3. 每个叶子结点(空结点)都是黑色
4. 任何红色节点的子结点一定是黑色(即不存在两个相连的红结点)
5. 任意结点到叶子节点的路径上的黑节点个数相同(黑高相同)

需要注意的是，在红黑树的结构中，我们把那些叶子节点之下的NULL结点称为叶子节点，并默认他们是黑色的。

我们简单分析以下4、5两条规则可知，*最短路径和最长路径中的黑结点个数相同，且不存在连续的红色节点*，那么最长路径就一定不会超过最短路径的两倍，最坏的情况就是最短节点都是黑节点，而最长路径是红黑结点交替的形式。

## 代码实现红黑树

### 一、结点的设计

STL中的map和set都是基于红黑树实现的，为了更好的理解map和set，我们这次采用模板的方式设计红黑树的结点，使其具有更好的可修改性和泛用性。

```
#include <iostream>

using namespace std;

enum Color
{
    red,black
};


template <class K, class T>
struct RBTreeNode
{
    RBTreeNode<K,T>* _parent; // 父结点
    RBTreeNode<K,T>* _left;   // 左子结点
    RBTreeNode<K,T>* _right;  // 右子结点
    Color _color;//结点颜色
    pair<K, T> data;//存储的pair

    /*构造函数初始化*/
    RBTreeNode<K, T>(pair<K, T> wpair,Color wcolor)
        :data(wpair)
        ,_color(wcolor)
        ,_parent(nullptr)
        ,_left(nullptr)
        ,_right(nullptr)
        {}
};
```

    